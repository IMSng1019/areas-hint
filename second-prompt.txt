这里是第二阶段的提示词
这些功能有的实现了有的没有实现
我不需要你现在为我写这些功能的代码 这些代码我后面会发给你
以下的话是提示词内容：
在原有的json格式后面再加一个高度altitude （max，min）这个是指的是域名在y轴所覆盖的范围
完整格式为{"name": "这里是区域名称（我将其定义为域名 这个定义上下文通用）", "vertices": [这是多边形的一个点,{"x":横坐标,"z":纵坐标},{"x":横坐标,"z":纵坐标},{"x":横坐标,"z":纵坐标}],"second-vertices":[{"x":横向最小坐标值,"y":纵向最大坐标值},{"x":横向最大坐标值,"y":纵向最大坐标值},{"x":横向最大坐标值,"y":纵向最小坐标值},{"x":横向最小坐标值,"y":纵向最小坐标值}],"altitude": {"max":最大的高度,"min":最小的高度"},"level": 指域名等级（ 必须为整数 数字越大域名等级越小 1为顶级域名 2为二级域名 3为三级域名 2和3为次级域名 注意 1对于域名等级并不是最大值 ） ,"base-name":"这里是该域名所指向的是上一级的域名（指向的域名的域名等级必须等于该域名等级-1,null就是无上级域名）"}

补充：altitude的max好min后面跟数字或null null代表该选项的高度无限制   在/areahint add 指令中应该要判断altitude的格式是否合规 
注意：altitude不用于原有的计算 不要更改之前的文件 是属于之后定点预筛的选项 

我要在原有的基础上加一层高度顶点预筛 用来筛选符合相应高度的域名 这个应该专门创建一个文件并写入README文件的文件结构
关于顶点预筛 就是在原有的处理机制前加一层预筛机制 用于筛选出符合要求的域名交给原有的处理机制进行处理 每新加的筛选机制都应该不影响原有的处理 并新建一个该处理机制文件
在射线法等步骤处理前 读取玩家所在位置的高度 将玩家的高度与所有域名的高度相比较 若玩家的高度大于域名最低高度小于域名最高高度 则该域名为符合相应高度的域名   再将所有符合相应高度的域名交给原有的处理机制进行处理 先不要写代码 给我说如何实现 逻辑是否正常
为什么高度的这个机制可以完美适配原有的机制呢 是因为高度的添加相当于是把原来的平面变成了柱形的立方 在相应高度内截出来的相同高度的横截面仍然为原来的平面也仍然是原来的向量 符合原有的逻辑 若不在域名的高度内则就截不到横截面就不包括相应的向量 那么就不在此域名内符合逻辑 所以是可以完美适配原来的机制的

如果一个域名没有altitude 设置altitude为null
完整格式为{"name": "这里是区域名称（我将其定义为域名 这个定义上下文通用）", "vertices": [这是多边形的一个点,{"x":横坐标,"z":纵坐标},{"x":横坐标,"z":纵坐标},{"x":横坐标,"z":纵坐标}],"second-vertices":[{"x":横向最小坐标值,"y":纵向最大坐标值},{"x":横向最大坐标值,"y":纵向最大坐标值},{"x":横向最大坐标值,"y":纵向最小坐标值},{"x":横向最小坐标值,"y":纵向最小坐标值}],"altitude": {"max":最大的高度,"min":最小的高度"},"level": 指域名等级（ 必须为整数 数字越大域名等级越小 1为顶级域名 2为二级域名 3为三级域名 2和3为次级域名 注意 1对于域名等级并不是最大值 ） ,"base-name":"这里是该域名所指向的是上一级的域名（指向的域名的域名等级必须等于该域名等级-1,null就是无上级域名）,"signature":null(的是该域名的创建者 null指无创建者)}
delete指令和域名签名
现在要在原有的json格式后面再加一个签名signature 这个是指的是该域名的创建者 
子指令 : `/areahint delete`
1.  名称：`delete`
2.  功能：输入该指令 后面给出所有的域名 选择该域名后 首先检测该域名的签名是否为当前使用指令的该玩家或者为拥有op权限的玩家（权限等级：2） 如果不是则显示你不是该域名创建者 如果是与签名相同的玩家或者为拥有op权限的玩家（权限等级：2）则检测该域名下有没有次级域名（被base-name引用的域名） 如果有则显示不能删除因为该域名下有子域名 如果没有次级域名则服务端在相应文件中删除该域名  之后服务端要将新的域名文件发送给客户端 客户端应当接受新的域名文件并更新之前的域名文件然后重新载入该模组并重新读取配置文件和域名文件（就是执行一次reload指令）如果该域名没有签名则不可以被删除（适配旧版本） 
目标选择器：作用于服务器文件
权限等级：0


easyadd
子指令 : `/areahint easyadd`
1.  名称：`easyadd`
2. 目的：这个指令是add指令的升级版 但两个指令都应该存在并互不干扰 easyadd旨在为普通玩家提供一个易于添加域名的功能
3.  功能：该指令涉及服务端与客户端的
目标选择器：作用于客户端与服务端双端的功能
客户端：在输入指令后先询问区域名称再询问域名等级：如果域名等级为1（顶级域名）则Base name为null（无），如果域名等级为二或者3，则列出当前域名等级减一的域名（该等级域名的上级域名）询问该域名所引用的域名，并将其设为base name，在这之后就开始记录域名范围 客户端应提供一个按键（默认为T，这个应该要写入配置文件中，用来记录一级顶点） 该按键按下时记录该点的坐标信息（xyz）每按一次则在对话框中发送已记录该坐标并且后面要跟着该坐标的信息和两个选项 第一个选项是不保存该域名 第二个选项是保存该域名。点击第一个选项则本次指令不做任何更改。点击第二个选项则将计算出该域名的二级顶点。客户端应该要读取客户端的域名文件计算出，该域名的一级顶点是否在所引用的域名的一级顶点之内，该域名的高度是否在所引用的域名的高度之内，如果都在之内，则将该域名和玩家所处在的维度发送给服务端，交给服务端处理
注意：主要的运算放在客户端的上面
服务端：需要接收客户端发来的域名，服务端会将其写入相对应的维度的域名文件中，并将其重新分发给每一个玩家（相当于执行一次reload指令）
权限等级：0


游戏内配置面板
将配置文件内所有选项可以在模组菜单中更改
注意：仅局限于配置文件


维度域名（也可以叫世界域名）
维度域名的等级是在于顶级域名之下的域名 是顶级域名更底层的存在（1为顶级域名 2为二级域名 3为三级域名 维度域名为0.5 ）
维度域名需要单独写一个文件 文件夹位于areas-hint文件夹之下（称为维度域名文件）
在离开顶级域名时应该跳出维度域名
加入世界时如果没有在任意一个域名之内则应该对应玩家所在的维度跳出维度域名
以下是默认的维度名字
主世界：蛮荒大陆
地狱：恶堕之域
末地：终末之地
对于这个功能需要添加一个指令以供在游戏内配置：

dimensionalityname
1.  名称：`/areahint dimensionalityname`
2. 目的：为了改变维度域名的名称而使用的指令
3.  功能：该指令后要列出所有的维度（overworld等等 需要查找当前服务器所有的世界）输入维度后就可以输入改变之后的维度域名 之后  服务端要将新的维度域名文件发送给客户端 客户端应当接受新的维度域名文件并更新之前的域名文件然后重新载入该模组并重新读取配置文件和域名文件（相当于执行一次reload）
reload指令在之前的基础上也需要更新维度域名文件你也要添加这个功能
目标选择器：作用于客户端与服务端双端的功能
权限等级：2（仅限op）

注意：目前areas-hint文件夹的生成位置是正确的 不要去改变areas-hint文件夹位置 目前生成的文件夹的路径是基于areas-hint文件夹生成位置的

动态频率
将检测玩家的频率变得更加智能 使玩家的电脑的平均负载更少
应该使用的算法：双因子自适应指数加权移动平均（Dual-Factor A-EWMA）
双因子A-EWMA算法在动态频率检测领域具有革命性优势，通过双状态协同感知和多层自适应机制实现了前所未有的性能突破
检测频率不能大于最大频率
使用该算法进行动态频率的检测最大频率为之前的配置文件中的frequently 并且将之前的最大默认频率设为15

世界文件夹
对于不同的世界 每个世界应该有属于自己的不同的域名文件和世界域名
在之前文件夹的基础上
在areas-hint文件夹下为进入的世界单独占有一个文件夹
每个文件夹格式：IP地址+世界名称
文件夹内只有域名文件和世界域名 没有配置文件（因为配置文件是应用于所有的世界 而域名文件是应用于单个世界）
当加入世界时 以IP地址+世界名称检测是否有相应的文件夹 如果有相应文件夹则设定之后关于域名文件的读取和修改都基于该文件夹
注意：目前areas-hint文件夹的生成位置是正确的 不要去改变areas-hint文件夹位置 目前生成的文件夹的路径是基于areas-hint文件夹生成位置的
这个功能你需要阅读所有关于需要读取和生成文件夹的代码，修改代码是其适配这一个新添加的功能
文件夹里的结构应该是.minecraft，文件夹下是areas-hint，areas-hint文件夹下是配置文件和每一个世界的世界文件夹，世界文件夹下是域名文件和世界域名
这一个实现服务端和客户端都可以这么用
但服务端不同的是服务端没有配置文件

子指令 : `/areahint renamearea`
1.  名称：`renamearea`
2.  功能：使用此指令时 向玩家列出所有的域名（列出的域名应该是可以更改名字的 指域名中的basename为当前玩家或者该玩家为管理员 权限等级为二）写下该域名的新域名后 对话框应该有一个二级确认（你确认将该域名更改为该名字吗 原域名:  新域名:   ［是］ ［否］  ）
确认后将玩家对应维度的域名文件的相应域名名字更改 并执行一次reload将文件重新分发
目标选择器：作用于服务器
权限等级：0 (不需要管理员)

模组的开关
本功能只作用于客户端 目的是为了让玩家自由选择是否使用该模组 模组的开关应该写入配置文件中 在每一次进入世界时检测状态 
模组打开时保持修改前的样子 模组关闭时不显示域名和不计算但仍应该接收来自服务器的文件

子指令 : `/areahint off`
1.  名称：`off`
2.  功能：使用此指令时 将该模组关闭（只指不显示域名和不计算）
目标选择器：作用于玩家自己
权限等级：0 (不需要管理员)

子指令 : `/areahint on`
1.  名称：`on`
2.  功能：使用此指令时 将该模组打开
目标选择器：作用于玩家自己
权限等级：0 (不需要管理员)

子指令 : `/areahint expandarea`
1.  名称：`expandarea`
2.  功能：使用此指令时 向玩家询问需要扩展的域名 输入域名后应检测该玩家是否为该域名的basename引用的玩家或者是管理员（权限等级为二） 如果是则列出所有可以被修改的域名（如果是普通玩家则为被basename引用的玩家的域名 如果玩家为管理员则列出所有域名）玩家选择域名后 模组提示按下X记录位置（这里与easyadd指令类似）当玩家按下按钮确认新添加的区域后 模组应该将新添加的顶点的最高高度与最低高度与原域名相比较 若新添加的区域的最高高度比原域名的最高高度小最低高度比原域名的最低高度高则不该变域名的高度 反之则将报错 如果没有报错模组应该计算新添加顶点是否在原域名内（包括在原域名边界上的） 如果有在原域名内的点 则计算其中的线段与原域名的点的线段的交叉点作为边界点 如果有相应的边界点则不用去计算相应顶点的边界点了 但是有可能会出现有一边在原域名内，但是有一边还是在外面的情况（我这里是排除了最开始点和最终点的线段） 有在原域名内的顶点都应该被删除 在剩下的顶点 计算初始点和末尾点（最开始玩家的起点和终点可能因为在域名内而被删除）与最近的两个点 （我称之临近点 一个点只能对应一个临近点） 再计算距离临近点最近的边界上的点（我称之边界点 每一个临近点都有一个） 这里这两个点可能会出现一个点有多个边界点的情况 这部分你看着处理我认为可以将一个点对应的多个最近的点进行取中位值再将那个点与这个中位置做直线与边界所交的点即为边界点  将边界点加入新添加的顶点当中（注意两个点在json中相对于新顶点的位置）判断边界点在哪两个点之间 将两个边界点之间的点删除（由于json中域名顶点为顺向排列 删除的为json中两个边界点距离最近之间的点）判断新顶点的插入方式（正向或者反向）将新添加顶点插入原域名（应该是像这样：原顶点 边界点 新顶点 边界点 原顶点 ）这里需要将有交叉的线段进行排序防止交叉（如果新添加入的区域的一级顶点与原有区域的顶点所连接成的线段有交叉则证明新添加入的区域的顶点的顺序反了） 重新排列新加入的区域的一级顶点 再进行插入 重新计算二级顶点 将完整域名 发送给服务端 服务端需要接收客户端发来的域名，服务端会将其写入相对应的世界的维度的域名文件中，并将其重新分发给每一个玩家（相当于执行一次reload指令）
目标选择器：作用于玩家自己和服务器
权限等级：0 (不需要管理员)

子指令 : `/areahint shrinkarea`
1.  名称：`shrinkarea`
2.  功能：该功能相当于expandarea指令的反义版本 用于收缩域名 使用此指令时 向玩家询问需要收缩的域名 输入域名后应检测该玩家是否为该域名的basename引用的玩家或者是管理员（权限等级为二） 如果是则列出所有可以被修改的域名（如果是普通玩家则为被basename引用的玩家的域名 如果玩家为管理员则列出所有域名）玩家选择域名后 模组提示按下X记录位置（这里与easyadd指令类似）当玩家按下按钮确认新删除的区域后 模组应该计算新添加顶点是否在原域名外（包括在原域名边界上的） 如果有在原域名外的点 则计算其中的线段与原域名的点的线段的交叉点作为边界点 如果有相应的边界点则不用去计算相应顶点的边界点了 但是有可能会出现有一边在原域名外，但是有一边还是在里面的情况（我这里是排除了最开始点和最终点的线段） 有在原域名内的顶点都应该被删除 在剩下的顶点 计算初始点和末尾点（最开始玩家的起点和终点可能因为在域名外而被删除）与最近的两个点 （我称之临近点 一个点只能对应一个临近点） 再计算距离临近点最近的边界上的点（我称之边界点 每一个临近点都有一个） 这里这两个点可能会出现一个点有多个边界点的情况 这部分你看着处理我认为可以将一个点对应的多个最近的点进行取中位值再将那个点与这个中位置做直线与边界所交的点即为边界点  将边界点加入新添加的顶点当中（注意两个点在json中相对于新顶点的位置）判断边界点在哪两个点之间 将两个边界点之间的点删除（由于json中域名顶点为顺向排列 删除的为json中两个边界点距离最近之间的点）判断新顶点的插入方式（正向或者反向）将新添加顶点插入原域名（应该是像这样：原顶点 边界点 新顶点 边界点 原顶点 ）这里需要将有交叉的线段进行排序防止交叉（如果新添加入的区域的一级顶点与原有区域的顶点所连接成的线段有交叉则证明新添加入的区域的顶点的顺序反了） 重新排列新加入的区域的一级顶点 再进行插入 重新计算二级顶点 将完整域名 发送给服务端 服务端需要接收客户端发来的域名，服务端会将其写入相对应的世界的维度的域名文件中，并将其重新分发给每一个玩家（相当于执行一次reload指令）
目标选择器：作用于玩家自己
权限等级：0 (不需要管理员)

子指令 : `/areahint sethigh`
1.  名称：`sethigh`
2.  功能：使用此指令时 检测该玩家是否为被域名的basename引用的玩家或者是管理员（权限等级为二） 如果是则列出所有可以被修改的域名（如果是普通玩家则为被basename引用的玩家的域名 如果玩家为管理员则列出所有域名）玩家选择域名后 展现被选择的域名的高度 并询问玩家是自定义高度还是不限制高度 选择自定义高度则依次询问最高高度和最低高度 然后将高度结果发给服务器 服务器修改玩家所在世界的相应维度的域名文件并将其重新分发给每一个玩家（相当于执行一次reload指令）
目标选择器：作用于服务器
权限等级：0 (不需要管理员)

域名颜色
将每一个域名都配置一个颜色 如果域名没有color则默认为白色 在显示域名字样时 应该使用对应域名的颜色
注意：每一次显示域名字样时都应该检查一次  在不同的显示方式（配置文件的SubtitleRender）都应该适配 显示的那部分的域名用那部分的颜色 "·"符号为白色（起分割作用） 如：顶级域名（金色）·（白色）二级域名（绿色）再如：顶级域名（金色）·（白色）二级域名（绿色）·（白色）三级域名（蓝色） 

在easyadd指令也要添加添加颜色的询问 应该提供按钮（［白色］［红色］［粉红色］［橙色］［黄色］［棕色］［浅绿色］［深绿色］［浅蓝色］［深蓝色］［浅紫色］［紫色］［灰色］［黑色］［自定义颜色］）选择相应颜色则在提交时用相应颜色的十六进制代码 选择自定义颜色则要玩家自己输入十六进制代码（选择自定义颜色需要检查是否符合格式）

完整格式为{"name": "这里是区域名称（我将其定义为域名 这个定义上下文通用）", "vertices": [这是多边形的一个点,{"x":横坐标,"z":纵坐标},{"x":横坐标,"z":纵坐标},{"x":横坐标,"z":纵坐标}],"second-vertices":[{"x":横向最小坐标值,"y":纵向最大坐标值},{"x":横向最大坐标值,"y":纵向最大坐标值},{"x":横向最大坐标值,"y":纵向最小坐标值},{"x":横向最小坐标值,"y":纵向最小坐标值}],"altitude": {"max":最大的高度,"min":最小的高度"},"level": 指域名等级（ 必须为整数 数字越大域名等级越小 1为顶级域名 2为二级域名 3为三级域名 2和3为次级域名 注意 1对于域名等级并不是最大值 ） ,"base-name":"这里是该域名所指向的是上一级的域名（指向的域名的域名等级必须等于该域名等级-1,null就是无上级域名）,"signature":null(的是该域名的创建者 null指无创建者) ,"color":"这里是十六进制表示法"}

子指令 : `/areahint recolor`
1.  名称：`recolor`
2.  功能：使用此指令时 向玩家列出所有的域名（列出的域名应该是可以更改颜色的 指域名中的basename为当前玩家或者该玩家为管理员 权限等级为二）开始询问颜色 应该提供按钮（［白色］［红色］［粉红色］［橙色］［黄色］［棕色］［浅绿色］［深绿色］［浅蓝色］［深蓝色］［浅紫色］［紫色］［灰色］［黑色］［自定义颜色］ 对话框应该有一个二级确认（你确认将该域名的颜色更改为该颜色吗 原颜色:  新颜色:   ［是］ ［否］  ）
确认后将玩家对应维度的域名文件的相应域名的十六进制的颜色（选择自定义颜色需要检查是否符合格式）更改 并执行一次reload将文件重新分发
目标选择器：作用于服务器
权限等级：0 (不需要管理员)

联合域名与check指令
在原有域名格式后面增加surfacename（表面域名 我称之为联合域名）
现在完整格式为{"name": "这里是区域名称（我将其定义为域名 这个定义上下文通用）", "vertices": [这是多边形的一个点,{"x":横坐标,"z":纵坐标},{"x":横坐标,"z":纵坐标},{"x":横坐标,"z":纵坐标}],"second-vertices":[{"x":横向最小坐标值,"y":纵向最大坐标值},{"x":横向最大坐标值,"y":纵向最大坐标值},{"x":横向最大坐标值,"y":纵向最小坐标值},{"x":横向最小坐标值,"y":纵向最小坐标值}],"altitude": {"max":最大的高度,"min":最小的高度"},"level": 指域名等级（ 必须为整数 数字越大域名等级越小 1为顶级域名 2为二级域名 3为三级域名 2和3为次级域名 注意 1对于域名等级并不是最大值 ） ,"base-name":"这里是该域名所指向的是上一级的域名（指向的域名的域名等级必须等于该域名等级-1,null就是无上级域名）,"signature":null(的是该域名的创建者 null指无创建者) ,"color":"这里是十六进制表示法","surfacename":"这里指联合域名"}

联合域名的功能在于使两个不同域名显现同一个名字 如果两个区域使用同一个域名会使basename的引用出错导致判断逻辑有bug并且使用easyadd指令/delete指令会不明白所引用的域名 所以保持域名的单一性是有必要的 为了使不同域名能显示相同字样 我采用该方法 引用的域名都为域名（name）域名为唯一的ID
我现在需要在跳出字样时检查域名内是否有surfacename 如果有surfacename输出对应域名的surfacename内的字样 如果没有则输出name内的字样
easyadd指令应该有所更新 在询问域名后 再询问联合域名 再进行后续步骤 最后应增加一个检查域名（name）是否有重复 如果重复则报错 如果不重复 则将完整域名（增加了surfacename的域名）提交给服务器

语言文件与language
模组内创建语言文件夹 所有的翻译文件都在语言文件夹下 便于后续添加
在配置文件中添加language选项默认为zh_cn（中文的语言文件）
将模组显示中文的部分（指在游戏中看得到的 代码注释不用管）翻译为英文 生成英文的语言文件 同时将原有的中文生成中文配置文件
每一次（注意是每一次）进入世界都应该先检查配置文件中使用的语言 使用相对应的语言的语言文件

子指令 : `/areahint language`
1.  名称：`language`
2.  功能：使用此指令时 检查翻译文件夹下的翻译文件 列出所有的翻译文件夹名字 玩家输入相应文件夹名字选择所使用的语言
目标选择器：作用于自己
权限等级：0 (不需要管理员)

对于新功能的代码应新开一个代码文件并在readme文件中的文件结构中写下相应文件和功能